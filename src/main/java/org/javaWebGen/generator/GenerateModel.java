/*
 * =================================================================== *
 * Copyright (c) 2017 Kevin Scott All rights  reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in
 * the documentation and/or other materials provided with the
 * distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 * if any, must include the following acknowledgment:
 * "This product includes software developed by "Kevin Scott"
 * Alternately, this acknowledgment may appear in the software itself,
 * if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The name "Kevin Scott must not be used to endorse or promote products
 * derived from this software without prior written permission. For
 * written permission, please contact kevscott_tx@yahoo.com
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL KEVIN SCOTT BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
 * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 */
package org.javaWebGen.generator;



import java.io.*;
import java.util.HashMap;
import java.util.ArrayList;
import org.apache.commons.text.StringSubstitutor;
import org.javaWebGen.exception.UtilException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


/**
 * create Models 
 * Generated Web Model Objects from the atabase configuration(torque)XML. 
 * creates a Service classes and a implementing class
 * This class Will be overwriten!
 * @author Kevin scott
 * @version $Revision: 1.2 $
 *
 */
public class GenerateModel extends CodeGenerator {
    
    public static final String VERSION="GenerateModel 2_10";
	private String className=null;
	private String subClassName=null;
	private final static Logger log = LoggerFactory.getLogger(GenerateModel.class);  
    private String classTemplate=
        "/*\n"+
        " Copyright (c) 2018 Kevin Scott All rights  reserved.\n"+
        " Permission is hereby granted, free of charge, to any person obtaining a copy of \n"+
        " this software and associated documentation files (the \"Software\"), to deal in \n"+
        " the Software without restriction, including without limitation the rights to \n"+
        " use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n"+
        " of the Software, and to permit persons to whom the Software is furnished to do \n"+
        " so.\n"+
        "\n"+
        " THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"+
        " IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"+
        " FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \n"+
        " AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"+
        " LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"+
        " OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE \n"+
        " SOFTWARE.\n "+
        "*/ \n"+            "/** data Acees Object talks to DB **/\n"+
        "package org.javaWebGen.model;\n"+
        "import java.util.*;\n"+
        "import javax.annotation.Generated;\n"+
        "import org.javaWebGen.data.bean.*;\n"+
        "import org.javaWebGen.*;\n"+
        "import org.javaWebGen.exception.WebAppException;\n"+
        "import org.javaWebGen.data.dao.*\n;"+

        "/******************************************************************************\n"+
        "* WARNING this class is generated by "+VERSION+" based on Database schema     \n"+
        "* This class should not be modified, but may be extended to add required logic \n"+
        "* It will be regenerated if the database schema changes \n"+
        "*******************************************************************************/\n"+
        "@Generated(value = { \"org.javaWebGen.generator.GenerateModel \" })\n"+
        "public abstract class ${javaWebGen.className} implements BusinessModel { \n"+
        "//begin private Vars\n"+
        "${javaWebGen.vars}\n"+
        "//find by Primary Key\n"	 +
        "${javaWebGen.finder}\n"+
        "//begin insert (create)\n"+
        "${javaWebGen.insert}\n"+
        "//begin update(store)\n"+
        "${javaWebGen.update}\n"+
        "//begin delete(store)\n"+
        "${javaWebGen.delete}\n"+
        "//begin listAll)\n"+
        "//${javaWebGen.list}\n"+
        "}\n";
        
        private String subClassTemplate=
            "/*\n"+
             " THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n"+
            " IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n"+
            " FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \n"+
            " AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n"+
            " LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \n"+
            " OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE \n"+
            " SOFTWARE.\n "+

           "*/ \n"+
        "package org.javaWebGen.model;\n\n"+

		"import javax.annotation.Generated;\n"+
        "import org.javaWebGen.config.ConfigConst;\n"+
		"import org.slf4j.Logger;\n"+
		"import org.slf4j.LoggerFactory;\n"+

        "/******************************************************************************\n"+
        "* This class is generated by "+VERSION+" based on Database schema     \n"+
        "* This class <b>should</b> be modified.  Business Logic goes here.\n" +
        "* The Implementation class that this class extends will handle all\n " +
        "* CRUD operations(Create,Update,Delete), and getById, and list all/\n "+
        "* This class will not get\n"+
        "* regenerated and is just generated as a place holder.\n"+
        "* @author Kevin Scott                                                        \n"+
        "* @version $Revision: 1.00 $                                               \n"+
        "*******************************************************************************/\n"+
        "@Generated(value = { \"org.javaWebGen.generator.GenerateModel\" })\n"+
        "public class ${javaWebGen.subClassName} extends ${javaWebGen.className} { \n"+
        "\t/** Model Logger */\n" +
        "@SuppressWarnings(\"unused\")\n"+
        "\tprivate final Logger log = LoggerFactory.getLogger(ConfigConst.MODEL_LOG);\n"+
        "}\n";

    
    /**
    *
    */
    public void init(){
    	classTemplate=getTemplate(classTemplate);
    	subClassTemplate=getTemplate(subClassTemplate);     
    }

    /************************************
    *gen class vars
    *************************************/
    private String makeVars(String[] cols, int[] types){
       // String beanName=DataMapper.formatClassName(tableName);
        String daoName=DataMapper.formatClassName(getTableName() )+"DAO";
        String text=
           "\t\n/** data bean for this object **/;\n"+
//            "\tprivate "+beanName+" dataBean;\n"+
       	"\tprivate "+daoName+" dao= new "+daoName+"();\n";
    

        return text;
    }  

    /***************************************************************************
	 * gen find by primary key
     * @throws Exception 
	 **************************************************************************/
	protected String makeFindByPrimaryKey(String[] keys, int[] types)  {
		String beanName = DataMapper.formatClassName(getTableName() );
		//ArrayList <String> primaryKeys = getPrimaryKeys();
		int[]primaryKeyTypes=this.getPrimaryKeyTypes();
		Object[] primaryKeys=getPrimaryKeys().toArray();
		getPrimaryKeys();
		String  getById=" getById(";
		if(primaryKeyTypes.length==0){
			return " //no primarykey";
		}
		if(primaryKeyTypes.length==1){
			getById+=DataMapper.getJavaTypeFromSQLType(primaryKeyTypes[0])+" id";
		 
		}else{
			 
			return "\t//Can only generate code for one Primary key per table \\nYou need to write custom code for this\n";
		 
		}
		getById+=")";
		
		String text =null;
		text = "\n\t/***************************************************\n"
				+ "\t* Get a Databean with table data in it\n"
				+ "\t* @return databean with data\n"
				+ "\t******************************************************/\n"
				+ "\tpublic "
				+ beanName
				+ getById+" throws WebAppException{\n"
				+ "\t\ttry{\n"
				+ "\t\t\t"+beanName + " bean=dao.findByPrimaryKey(id);\n"			
				+ "\t\t\t return bean;\n"
				+ "\t\t}catch(Exception e){\n"
				+ "\t\t\tthrow new WebAppException(WebAppException.APP_ERROR,e);\n"
				+ "}\n"
				+ "\t} //end getById\n";
		if(primaryKeyTypes.length==1){
			String javaType=DataMapper.getJavaTypeFromSQLType(primaryKeyTypes[0]);
			text += "\n\t/***************************************************\n"
					+ "\t* Get a Databean with table data in it\n"
					+ "\t* @return databean with data\n"
					+ "\t******************************************************/\n"
					+ "\tpublic "
					+ beanName
					+ " getByIdParm(String "+DataMapper.formatVarName(primaryKeys[0]+"Str")+") throws WebAppException{\n"
					+ "\t   if ("+DataMapper.formatVarName(primaryKeys[0]+"Str")+"!=null){\n"
					+ "\t   	return getById(new "+javaType+" ("+DataMapper.formatVarName(primaryKeys[0]+"Str")+") );\n"
					+ "\t   }else{\n"
					+ "\t     return null;\n"
					+ "\t   }\n"
					+ "\t} //end getByIdParm\n";
		}else {
			
			
			text += "\n\t/**\n"
						+ "\t* Get a Databean with table data in it\n"
						+ "\t* @return databean with data\n"
						+ "\t*/\n"
						+ "\tpublic "
						+ beanName
						+ " getByIdParm( String "+DataMapper.formatVarName(primaryKeys[0]+"Str")+"";
			if(primaryKeys.length>1) {	
				for(int i=1;i<primaryKeys.length;i++) {
					text +=", String "+DataMapper.formatVarName(primaryKeys[0]+"Str");
				}
			}
			text +=")throws WebAppException{\n;"
				+ "\t   if ("+DataMapper.formatVarName(primaryKeys[0]+"Str")+"!=null";
			if(primaryKeys.length>1) {
				for(int i=1;i<primaryKeys.length;i++) {
					text +="&& "+DataMapper.formatVarName(primaryKeys[0]+"Str")+"!=null";
				}
			}

			String javaType=DataMapper.getJavaTypeFromSQLType(primaryKeyTypes[0]);
			text +="){\n"
				+ "\t   	return getById(new "+javaType+" (idStr) ";
			if(primaryKeys.length>1) {
				for(int i=1;i<primaryKeys.length;i++) {
					text +=", new "+javaType+" ("+primaryKeys[i]+"Str);\n";
				} 
			}
			text +=");\n"
				+ "\t   }else{\n"
				+ "\t     return null;\n"
				+ "\t   }\n"
				+ "\t} //end getByIdParm\n";		
			text+="/* more than 1 primary key not supported currently*/";
			text+="/* you will need to write custome code to handle it*/"	;	
		}
		
		return text;
	}
    
    /***************************************************************************
	 * gen create(INSERT)
	 **************************************************************************/
	private String makeInsert(String[] cols, int[] types) {
		String beanName = DataMapper.formatClassName(getTableName() );
		int[] pkeyTypes= this.getPrimaryKeyTypes();
		if(pkeyTypes.length !=1){
			 return "\t//Can only generate code for one Primary key per table \\nYou need to write custom code for this\n";
		}
		String javaType=DataMapper.getJavaTypeFromSQLType(pkeyTypes[0]);
		String text = 
				"\n\t/***********************************************\n"
				+ "\t*Inserts new Databean \n"
				+ "\t@param bound Databean with data from data store"
				+ "\t*\n"
				+ "\t************************************************/\n"
				+ "\tpublic "+javaType+" create("
				+ beanName
				+ " bean) throws WebAppException{\n"
				+ "\t\ttry{\n"
				+ "\t\t\treturn dao.insert(bean);\n"
				+ "\t\t}catch(Exception e){\n"
				+ "\t\t\tthrow new WebAppException(WebAppException.APP_ERROR,e);\n"
				+ "\t\t}\n" + "\t} //end create\n";
		return text;
	}

    /***************************************************************************
	 * gen update(store)
	 **************************************************************************/
    private String makeUpdate(String[] cols, int[] types) {
    	int[] keytypes= this.getPrimaryKeyTypes();
		if(keytypes.length !=1){
			 return "\t//Can only generate code for one Primary key per table \\nYou need to write custom code for this\n";
		}
		String beanName = DataMapper.formatClassName(getTableName() );
		String text = "\n\t/***********************************************\n"
				+ "\t*Updates the database with a Databean \n"
				+ "\t*@param bound Databean to persist to data store"
				+ "\t******************************************************/\n"
				+ "\tpublic void save("
				+ beanName
				+ " bean) throws WebAppException{\n"
				+ "\t\ttry{\n"
				+ "\t\t\tdao.update(bean);\n" 
				+ "\t\t}catch(Exception e){\n"
				+ "\t\t\tthrow new WebAppException(WebAppException.APP_ERROR,e);\n"
				+ "\t\t}\n" 
				+ "\t} //end update\n";
		return text;
	}
    /***************************************************************************
	 * gen delete
	 **************************************************************************/
	private String makeDelete(String[] cols, int[] types) {
    	int[] keytypes= this.getPrimaryKeyTypes();
		if(keytypes.length !=1){
			 return "\t//Can only generate code for one Primary key per table \\nYou need to write custom code for this\n";
		}
		String beanName = DataMapper.formatClassName(getTableName() );
		String text = "\n\t/***************************************************\n"
				+ "\t*Deletes record from the database based on a Databean \n"
				+ "\t*@param bean from data store \n"
				+ "\t******************************************************/\n"
				+ "\tpublic void remove("
				+ beanName
				+ " bean) throws WebAppException{\n"
				+ "\t\ttry{\n"
				+ "\t\t\tdao.delete(bean);\n"
				+ "\t\t}catch(Exception e){\n"
				+ "\t\t\tthrow new WebAppException(WebAppException.APP_ERROR,e);\n"
				+ "\t\t}\n"
				+"\t} //end delete\n";
		return text;
	}   
     private String makeList(String[] colNames2, int[] colTypes2) {
		String beanName = DataMapper.formatClassName(getTableName() );
		String text = "\n\t/***************************************************\n"
				+ "\t* List of all records in a table \n"
				+ "\t* @return array of DataBeans\n"
				+ "\t******************************************************/\n"
				+ "\tpublic List<"+beanName+"> list() throws WebAppException{\n"
				+ "\t\tList<"+ beanName+"> dataBeans =null;\n" 
				+ " \t\ttry{\n"
				+ "\t\tdataBeans = dao.findAll();\n"
				+ "\t\t}catch(Exception e){\n"
				+ "\t\t\tthrow new WebAppException(WebAppException.APP_ERROR,e);\n"
				+ "\t\t}\n\t\treturn dataBeans;\n\t} //end list\n";
		return text;
	}

  
    
    /***************************************************************************
	 * build class based on template
	 **************************************************************************/
    protected String buldClass() throws Exception{
    	String[] colNames=getColNames();
    	int[] colTypes=getColTypes();

    		
        String vars = makeVars(colNames,colTypes);
        String finder = makeFindByPrimaryKey(colNames,colTypes);
        String insert = makeInsert(colNames,colTypes);
        String update = makeUpdate(colNames,colTypes);
        String delete = makeDelete(colNames,colTypes);
        String list = makeList(colNames,colTypes);
        /* String[] p = new String[7];
        p[0]= className;
        p[1]= vars;
        p[2]=finder;
        p[3]=insert;
        p[4]=update;
        p[5]=delete;
        p[6]=list;*/
    	HashMap<String,String>valueMap = new HashMap<String,String>();
     	valueMap.put("javaWebGen.className", className );
     	valueMap.put("javaWebGen.vars", vars );
     	valueMap.put("javaWebGen.finder", finder );
     	valueMap.put("javaWebGen.insert", insert );   	
     	valueMap.put("javaWebGen.update", update );   	
     	valueMap.put("javaWebGen.delete", delete );   	
     	valueMap.put("javaWebGen.list", list );   	
     	StringSubstitutor sub = new StringSubstitutor(valueMap);
        
        //debug(classTemplate);
        //String classText = StringUtil.replace(classTemplate,p);

        return sub.replace(classTemplate);
    }

	/**************************************************
    *build class based on template
    ********************************************************/
    protected String buldSubClass() throws Exception{
    
        /*String[] p = new String[3];
        p[0]= subClassName;
        p[1]= className;
        p[2]= subClassName;*/

       //String classText = StringUtil.replace(subClassTemplate,p);
    	HashMap<String,String>valueMap = new HashMap<String,String>();
     	valueMap.put("javaWebGen.subClassName", subClassName );
     	valueMap.put("javaWebGen.className", className );
  	
     	StringSubstitutor sub = new StringSubstitutor(valueMap);
        return sub.replace(subClassTemplate);
    }
    
    /**
    *
    */
    @Override
    protected void execute() throws UtilException{
    	try{
    		className=DataMapper.formatClassName(getTableName() )+"ModelImpl";
    		subClassName=DataMapper.formatClassName(getTableName() )+"Model";
	        writeJavaClass(buldClass() );
	        writeSubClass(buldSubClass() );
    	}catch(Exception e){
    		throw new UtilException(UtilException.CODE_GENERATOR_EXEC,e);
    	}
    }
    
    /**
    *Called after looping though all tables-columns
    *Good place to generate files that are not needed for every table
    *IE PMF etc...
    */
    @Override
    protected void postExecute() throws UtilException{
    	try{
    		className=DataMapper.formatClassName(getTableName() )+"ModelImpl";
    		subClassName=DataMapper.formatClassName(getTableName() )+"Model";
	        writeJavaClass(buldClass() );
	        writeSubClass(buldSubClass() );
    	}catch(Exception e){
    		throw new UtilException(UtilException.CODE_GENERATOR_EXEC,e);
    	}
    }
    
    /**
    *Write out generated class
    */
    private void writeJavaClass(String text) throws IOException{
        String name = className;
        ArrayList <String> primaryKeys=getPrimaryKeys();
        String fileName=getFilePath()+File.separator+name+".java";
        
      
        if(primaryKeys.size() >0){       
        	File file=new File(fileName);        
            FileWriter fw = new FileWriter(file);
            PrintWriter out = new PrintWriter(fw);
            out.print(text);
            out.flush();
            out.close();
            log.info("---write file="+fileName+"---");
        }
    }

    /**
    *Write out generated class
    */
    private void writeSubClass(String text) throws IOException{
        String name = subClassName;
        ArrayList <String> primaryKeys=getPrimaryKeys();
        String fileName=getFilePath()+File.separator+name+".java";
        if(primaryKeys.size() >0){
            File file = new File(fileName);
            if(!file.exists() ){
                FileWriter fw = new FileWriter(file);
                PrintWriter out = new PrintWriter(fw);
                out.print(text);
                out.flush();
                out.close();
                log.info("---write file="+fileName+"---");
            }
        }
    }   
  
     
   
 
	/**
     * main
     */
     public static void main(String[] args) {
         try{ 	
         	GenerateModel app = new GenerateModel();
         	app.setCmdParms(args);
         	app.init();
             app.processXmlFile(app.getFileName());
        	}catch(Exception e){
        		log.error("main",e);
        		System.exit(911);
        	}
     }
 /**
  * 
  */
 	public void useage() {
 
         System.out.println("To Process all tables in a text file");
         System.out.println("USAGE GenerateModel <schema XML> <path>");
         System.exit(1);
 	}

}

